---
layout: post
title: Rust 1.45.0
author: The Rust Release Team
release: true
---

Команда Rust рада сообщить о выпуске новой версии, 1.45.0. Rust — это язык программирования, позволяющий каждому создавать надёжное и эффективное программное обеспечение.

Если вы установили предыдущую версию Rust средствами `rustup`, то для обновления до версии 1.45.0 вам достаточно выполнить следующую команду:

```console
rustup update stable
```

Если у вас ещё не установлен `rustup`, вы можете [установить его](https://www.rust-lang.org/install.html) с соответствующей страницы нашего веб-сайта, а также посмотреть [ на GitHub.](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1450-2020-07-16)

## Что вошло в стабильную версию 1.45.0

Данный выпуск содержит два больших изменения: исправление давних дефектов при преобразовании между целыми числами и числами с плавающей точкой и стабилизация фич, необходимых чтобы как минимум один web-фрейморк мог работать на стабильном Rust.

## Исправление дефектов в преобразованиях

Изначально [Issue 10184](https://github.com/rust-lang/rust/issues/10184) была открыта в октябре 2013 года, за полтора года до выпуска Rust 1.0. Как вы можете знать, `rustc` использует [LLVM](http://llvm.org/) в качестве backend-компилятора. Когда вы пишете подобный код:

```rust
pub fn cast(x: f32) -> u8 {
    x as u8
}
```

компилятор Rust в версиях 1.44.0 и раньше генерировал следующее LLVM-IR:

```llvm-ir
define i8 @_ZN10playground4cast17h1bdf307357423fcfE(float %x) unnamed_addr #0 {
start:
  %0 = fptoui float %x to i8
  ret i8 %0
}
```

`fptoui` реализует преобразование и является сокращением от "floating point to unsigned integer".

Но здесь есть проблема, [описанная в документации](https://llvm.org/docs/LangRef.html#fptoui-to-instruction):

> Инструкция ‘fptoui’ преобразовывает операнд с плавающей точкой в ближайшее (округляя до нуля) беззнаковое целое значение. Если значение не помещается в `ty2`, то результирующее значение будет испорченным. <!-- добавить оригинал -->

Следующая часть, если только вы регулярно не копаетесь в недрах компиляторов, может быть вам не понятна. Она полна жаргона, но есть более простое объяснение: если вы приводите большое число с плавающей запятой к маленькому целому числу, вы получаете неопределенное поведение.

Это означает, что например следующий код, не полностью определён:

```rust
fn cast(x: f32) -> u8 {
    x as u8
}

fn main() {
    let f = 300.0;

    let x = cast(f);

    println!("x: {}", x);
}
```

On Rust 1.44.0, this happens to print "x: 0" on my machine. But it could print anything, or do anything: this is undefined behavior. But we have no `unsafe` code here. This is what we call a "soundness" bug, that is, it is a bug where the compiler does the wrong thing. We tag these bugs as [I-unsound](https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+label%3A%22I-unsound+%F0%9F%92%A5%22) on our issue tracker, and take them very seriously.

This bug took a long time to resolve, though. The reason is that it was very unclear what the correct path forward was.

In the end, the decision was made to do this:

- `as` would perform a "saturating cast".
- A new `unsafe` cast would be added if you wanted to skip the checks.

This is very similar to array access, for example:

- `array[i]` will check to make sure that `array` has at least `i + 1` elements.
- You can use `unsafe { array.get_unchecked(i) }` to skip the check.

So, what's a saturating cast? Let's look at a slightly modified example:

```rust
fn cast(x: f32) -> u8 {
    x as u8
}

fn main() {
    let too_big = 300.0;
    let too_small = -100.0;
    let nan = f32::NAN;

    println!("too_big_casted = {}", cast(too_big));
    println!("too_small_casted = {}", cast(too_small));
    println!("not_a_number_casted = {}", cast(nan));
}
```

This will print:

```text
too_big_casted = 255
too_small_casted = 0
not_a_number_casted = 0
```

That is, numbers that are too big turn into the largest possible value. Numbers that are too small produce the smallest possible value (which is zero). NaN produces zero.

The new API to cast in an unsafe manner is:

```rust
let x: f32 = 1.0;
let y: u8 = unsafe { x.to_int_unchecked() };
```

But as always, you should only use this method as a last resort. Just like with array access, the compiler can often optimize the checks away, making the safe and unsafe versions equivalent when the compiler can prove it.

## Stabilizing function-like procedural macros in expressions, patterns, and statements

In [Rust 1.30.0](https://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html), we stabilized "function-like procedural macros in item position." For example, [the `gnome-class` crate](https://gitlab.gnome.org/federico/gnome-class):

> Gnome-class is a procedural macro for Rust.  Within the macro, we define a mini-language which looks as Rust-y as possible, and that has extensions to let you define GObject subclasses, their properties, signals, interface implementations, and the rest of GObject's features.  The goal is to require no unsafe code on your part.

This looks like this:

```rust
gobject_gen! {
    class MyClass: GObject {
        foo: Cell<i32>,
        bar: RefCell<String>,
    }

    impl MyClass {
        virtual fn my_virtual_method(&self, x: i32) {
            ... do something with x ...
        }
    }
}
```

The "in item position" bit is some jargon, but basically what this means is that you could only invoke `gobject_gen!` in certain places in your code.

Rust 1.45.0 adds the ability to invoke procedural macros in three new places:

```rust
// imagine we have a procedural macro named "mac"

mac!(); // item position, this was what was stable before

// but these three are new:
fn main() {
  let expr = mac!(); // expression position

  match expr {
      mac!() => {} // pattern position
  }

  mac!(); // statement position
}
```

Being able to use macros in more places is interesting, but there's another reason why many Rustaceans have been waiting for this feature for a long time: [Rocket](https://rocket.rs). Initially released in December of 2016, Rocket is a popular web framework for Rust often described as one of the best things the Rust ecosystem has to offer. Here's the "hello world" example from its upcoming release:

```rust
#[macro_use] extern crate rocket;

#[get("/<name>/<age>")]
fn hello(name: String, age: u8) -> String {
    format!("Hello, {} year old named {}!", age, name)
}

#[launch]
fn rocket() -> rocket::Rocket {
    rocket::ignite().mount("/hello", routes![hello])
}
```

Until today, Rocket depended on nightly-only features to deliver on its promise of flexibility and ergonomics. In fact, as can be seen on the [project's homepage](https://rocket.rs/v0.4), the same example above in the current version of Rocket requires the `proc_macro_hygiene` feature to compile. However, as you may guess from the feature's name, today it ships in stable! [This issue](https://github.com/SergioBenitez/Rocket/issues/19) tracked the history of nightly-only features in Rocket. Now, they're all checked off!

This next version of Rocket is still in the works, but when released, many folks will be very happy :)

### Изменения в стандартной библиотеке

В Rust 1.45.0 были стабилизированы следующие функции:

- [`Arc::as_ptr`](https://doc.rust-lang.org/stable/std/sync/struct.Arc.html#method.as_ptr)
- [`BTreeMap::remove_entry`](https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html#method.remove_entry)
- [`Rc::as_ptr`](https://doc.rust-lang.org/stable/std/rc/struct.Rc.html#method.as_ptr)
- [`rc::Weak::as_ptr`](https://doc.rust-lang.org/stable/std/rc/struct.Weak.html#method.as_ptr)
- [`rc::Weak::from_raw`](https://doc.rust-lang.org/stable/std/rc/struct.Weak.html#method.from_raw)
- [`rc::Weak::into_raw`](https://doc.rust-lang.org/stable/std/rc/struct.Weak.html#method.into_raw)
- [`str::strip_prefix`](https://doc.rust-lang.org/stable/std/primitive.str.html#method.strip_prefix)
- [`str::strip_suffix`](https://doc.rust-lang.org/stable/std/primitive.str.html#method.strip_suffix)
- [`sync::Weak::as_ptr`](https://doc.rust-lang.org/stable/std/sync/struct.Weak.html#method.as_ptr)
- [`sync::Weak::from_raw`](https://doc.rust-lang.org/stable/std/sync/struct.Weak.html#method.from_raw)
- [`sync::Weak::into_raw`](https://doc.rust-lang.org/stable/std/sync/struct.Weak.html#method.into_raw)
- [`char::UNICODE_VERSION`](https://doc.rust-lang.org/stable/std/char/constant.UNICODE_VERSION.html)
- [`Span::resolved_at`](https://doc.rust-lang.org/stable/proc_macro/struct.Span.html#method.resolved_at)
- [`Span::located_at`](https://doc.rust-lang.org/stable/proc_macro/struct.Span.html#method.located_at)
- [`Span::mixed_site`](https://doc.rust-lang.org/stable/proc_macro/struct.Span.html#method.mixed_site)
- [`unix::process::CommandExt::arg0`](https://doc.rust-lang.org/std/os/unix/process/trait.CommandExt.html#tymethod.arg0)

Additionally, you can [use `char` with ranges](https://github.com/rust-lang/rust/pull/72413/), to iterate over codepoints:

```rust
for ch in 'a'..='z' {
    print!("{}", ch);
}
println!();
// Выведет "abcdefghijklmnopqrstuvwxyz"
```

Полный список изменений вы можете увидеть в [детальных примечаниях к выпуску](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1450-2020-07-16).

### Другие изменения

[Синтаксис](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1450-2020-07-16), [пакетный менеджер Cargo](https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-145-2020-07-16) и [анализатор Clippy](https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-145) также претерпели некоторые изменения.

## Участники 1.45.0

Множество людей собрались вместе, чтобы создать Rust 1.45.0. Мы не смогли бы сделать это без всех вас, [спасибо](https://thanks.rust-lang.org/rust/1.45.0/)!
